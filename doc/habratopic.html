<h4>Навигация по странице</h4>
Всё чаще и чаще в web появляются сайты, использующие навигацию, написанную на JavaScript. Типичный случай использования javascript для навигации: страница с меню и блоком контента, куда через AJAX подгружается содержимое:

<a href="https://sourceforge.net/apps/trac/jsnavigator/raw-attachment/wiki/AjaxSite/sample.png"><img border="0" width="200pt" src="static/sample.png"/></a>

Пользователь кликает по пункту, JavaScript грузит из сети содержимое, вставляет в блок контента, пользователь доволен: страница без перезагрузки показывает требуемое и траффика потребовалось меньше за счёт того, что не потребовалось грузить все эти HEAD, BODY, STYLE и прочие элементы.

Но вот проблема: URL страницы. Если на old scool сайтах на каждый пункт меню показывается новая HTML страница, и у пользователя есть вменяемый URI, который он может скопировать из адресной строки бразуера, послать другу или положить в закладки, то в случае AJAX интерфейсов в URI странице зачастую нет никаких ссылок на текущий контент документа. 

Пересылая ссылку из адресной строки браузера другу, пользователь не может быть уверен, откроется ли документ с тем содержимым, что он просматривает сейчас, или откроется документ с начальным содержимым страницы.

Не с секрет, что для решения этой проблемы многие программисты кодируют ссылку на текущее просматриваемое содержимое в якорь (anchor) URI документа. К примеру, на сайте http://jqapi.com (скриншот которого приведён вначале топика) при выборе того или иного пункта меню якорь страницы меняется на #p={contentId}.<habracut /> 

К примеру:
http://jqapi.com/#p=jQuery.ajax
http://jqapi.com/#p=height
http://jqapi.com/#p=addClass

В этом случае после загрузки страницы по якорю в ссылке можно просто восстановить и показать запрашиваемое содержимое.

К сожалению, на данный момент каждый изобретает свои велосипеды для решения проблемы кодирования в якоре текущего содержимого документа. Нет единого стандарта кодирования якорей. Кроме того, разработчики зачастую забывают для чего изначально использовались якоря и лишают пользователя возможности навигации внутри документа.

Чтобы как-то решить эти проблемы к нам в голову с хабраюзером <hh user="gbezyuk"/> пришла идея создания библиотеки <a href="https://sourceforge.net/apps/trac/jsnavigator/wiki/WikiStartRu">JSNAV</a>, которая помогает решить указанные выше проблемы.

<h5>Как это работает?</h5>
JSNAV кодирует вызовы JavaScript обработчиков в URI документа. Для кодирования используется <a href="http://tools.ietf.org/html/rfc1630">RFC1630</a> совместимые URI следующего вида: 
<code>http://user:pass@host:port/path/resource?query#anchor;navEventName;param1;param2;...</code>

Cинтаксис якоря страницы: <ul><li>до служебного символа # URI страницы ничем не отличается, от указанного в стандарте, изменения касаются лишь синтаксиса якоря</li>
<li>сразу же после # и до символа ; идёт обычный HTML якорь со стандартным действием (прокручивание страницы до элемента якоря)</li>
<li>после якоря идёт служебный символ ; и указывается имя события </li>
<li>далее через символ ; идёт список параметров, с которыми будут вызваны обработчики событий; параметры закодированы в URL encoding в байтовой кодировке UTF-8</li></ol>
Библиотека после загрузки страницы начинает следить за изменениями URI по переменной window.location.href и, в случае его изменения, вызывает зарегистрированные обработчики.

JSNAV так же поддерживает работу с и обычными якорями: в случае перехода по ссылке с якорем производится scrollTo к элементу якоря. При этом в URI сохраняется описание последнего зарегистрированного события.

Обработчики представляют из себя обычные function объекты, на вход которым передаются декодированные из якоря параметры события.

<blockquote><code><font size="2" face="Courier New" color="black"><font color="#0000ff">var</font> addClassHandler = <font color="#0000ff">function</font>(className, textId) {
&nbsp;&nbsp;<font color="#0000ff">var</font> elm = textId? <font color="#0000ff">document</font>.getElementById(textId) : <font color="#0000ff">this</font>;
&nbsp;&nbsp;<font color="#0000ff">if</font> (elm.className &#38;&#38; elm.className.indexOf(className) &#60; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;elm.className += <font color="#A31515">" "</font> + className;
&nbsp;&nbsp;}
}
JSNAV.bind(<font color="#A31515">"addClass"</font>, addClassHandler);</font>
</code></blockquote>
Обработчик addClassHandler из примера будет вызываться на URI вида: <ul>
<li>test.html#;addClass - вызов addClassHandler() в контексте window.document.body </li>
<li>test.html#;addClass;className  - вызов addClassHandler('className') в контексте window.document.body </li>
<li>test.html#;addClass;className;elementId - вызов addClassHandler('className', 'elementId') в контексте window.document.body </li>
<li>test.html#anchor;addClass;className - вызов addClassHandler('className') в контексте элемента якоря (элемента с id=='anchor' или name=='anchor') и прокрутка до элемента якоря</li></ul>
<h5>JSNAV</h5>
Библиотека написана на pure JS и, по идее, не должна конфликтовать ни с одним из известных фреймворков.

Зарепортить ошибку, предложить патч или скачать код можно на <a href="https://sourceforge.net/apps/trac/jsnavigator/wiki/WikiStartRu">сайте проекта</a>. Исходники доступны под Apache2 License.

Посмотреть, как всё это работает можно в примере на <a href="http://jsnavigator.sourceforge.net/sample.html">этой странице</a>. 

<h5>P.S.</h5>
Буду рад услышать комментарии, пожелания, получить баг-репорты. Кроме того приглашаю всех желающих присоединиться к разработке кода и документации.